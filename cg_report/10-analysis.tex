\chapter{Аналитический раздел}
\fontsize{16}{19}\selectfont

В данном разделе выполнены формализация задачи в виде IDEF0-диаграммы, дан обзор алгоритмов построения теней, удаления невидимых рёбер и граней, алгоритмов закрашивания.

\section{Формализация задачи}

Функциональная модель программы в нотации IDEF0 представлена на рисунке \ref{img:idef02}:

\img{8.5cm}{idef02}{Функциональная модель программы}

\section{Формализация объектов синтезируемой сцены}
\label{sec:formalize}

Исходя из ожидаемых результатов работы программы, кадр видео должен содержать следующие объекты:
\begin{itemize}
	\item[---] шарик, представляющий собой сферу;
	\item[---] качели, имеющие форму параллелепипеда со скруглёнными углами (каждая качель имеет крепление).
\end{itemize}

Основные свойства шарика и качелей:
\begin{enumerate}
	\item цвет поверхности;
	\item выпуклость;
	\item оптические свойства материала:
		\begin{itemize}
			\item[---] диффузная компонента освещённости $k_d$;
			\item[---] фоновая компонента освещённости $k_a$;
			\item[---] зеркальная составляющая освещённости $k_s$;
		\end{itemize}
	\item скорость движения.
\end{enumerate}

Сцена содержит камеру, которая характеризуется свойствами:
\begin{enumerate}
	\item положение в пространстве $P$;
	\item вектор наблюдения $V$.
\end{enumerate}

Cцена содержит направленные источники света, имеющие свойства:
\begin{enumerate}
	\item вектор направления лучей $D$;
	\item мощность $S$.
\end{enumerate}

\section{Анализ способов задания трёхмерных\newline объектов}
Существуют несколько способов моделирования трёхмерных объектов:
\begin{itemize}
	\item[---] аппроксимация поверхностей объекта многоугольниками (например, треугольниками) --- данный тип называется \textbf{поверхностным}~\cite{rodjers};
	\item[---] задание объекта набором точек и соединяющих рёбер --- это \textbf{каркасный} тип модели~\cite{rodjers};
	\item[---] формирование тела  из отдельных простых геометрических объёмных элементов с помощью операций объединения, пересечения, вычитания и различных преобразований --- модель \textbf{сплошных тел}~\cite{rodjers}.
\end{itemize}

Результат сравнения способов задания трёхмерных объектов приведен в таблице~\ref{tbl:1}:

\tableimg{4.3cm}{1}{Сравнение способов задания моделей}

\subsection*{Вывод}

Для выполнения курсовой работы был выбран поверхностный способ задания объектов, так как существуют программы для 3D-моделирования (Blender, Autocad), которые позволяют экспортировать модели в поверхностном типе.

\section{Анализ алгоритмов удаления невидимых рёбер и поверхностей}
Удаление невидимых рёбер и поверхностей разделяют на две задачи~\cite{rodjers}:
\begin{enumerate}
	\item удаление всех не лицевых поверхностей/рёбер;
	\item удаление всех видимых поверхностей/рёбер, экранируемых другими телами.
\end{enumerate}

Алгоритмы удаления невидимых рёбер и поверхностей разделяют на классы в зависимости от пространства работы: пространство объекта или пространство изображения~\cite{rodjers, geom}.

\begin{enumerate}
	\item Алгоритмы, работающие в пространстве \textbf{объекта}: 
		\begin{itemize}
			\item[---] алгоритм Робертса;
			\item[---] алгоритм Вейлера-Азертона.
		\end{itemize}
	\item Алгоритмы, работающие в пространстве \textbf{изображения}: 
		\begin{itemize}
			\item[---] алгоритм плавающего горизонта;
			\item[---] алгоритм с Z-буфером;
			\item[---] алгоритм трассировки лучей;
			\item[---] алгоритм Варнока.
		\end{itemize}
\end{enumerate}

\subsection{Алгоритм плавающего горизонта}

Алгоритм плавающего горизонта чаще всего используется для удаления невидимых линий трехмерного представления функций, описывающих поверхность в виде: $F(x, y, z) = 0$.

Данный алгоритм не подходит для моделирования объектов, заданных каркасным, поверхностным способом или моделью сплошных тел~\cite{geom}.

\subsection{Алгоритм, использующий Z-буфер}

Алгоритм, использующий Z-буфер, в специальном буфере для каждого пикселя изображения хранит координату Z и значения RGB-составляющих цвета пикселя. Чтобы отсечь невидимые поверхности, используется сравнение значений в буфере с координатами текущего пикселя~\cite{rodjers}.

Формальное описание алгоритма, использующего Z-буфер:
\begin{enumerate}
	\item буфер кадра заполняется фоновым значением интенсивности или цвета;
	\item Z-буфер заполняется минимальным значением глубины;
	\item каждый отрисовываемый многоугольник преобразуется в растровую форму в произвольном порядке;
	\item для каждого $Pixel(x, y)$ в многоугольнике:
	\begin{enumerate}
		\item[4.1.] вычисляется его глубина $z(x, y)$;
		\item[4.2.] если $z(x, y) > Z_{buf}(x, y)$, то атрибут этого многоугольника (интенсивность, цвет и т. п.) записывается в буфер кадра и $Z_{buf}(x, y)$ заменяется на $z(x, y)$;
	\end{enumerate}
\end{enumerate}  

При использовании алгоритма Z-буфера визуализация пересечений сложных объектов не требует дополнительных модификаций. Однако, чтобы хранить два буфера кадра, необходим большой объём памяти~\cite{rodjers, cg}.

\subsection{Алгоритм трассировки лучей}

Главная идея, составляющая основу алгоритма трассировки лучей, заключается в том, что наблюдатель видит объекты посредством испускаемого неким источником луча света, который падает на объект и затем доходит до наблюдателя, отражаясь, преломляясь или каким-нибудь иным способом.

Для более эффективной работы алгоритма лучи отслеживаются от наблюдателя к объекту.

Итак, из позиции наблюдателя $P$ через каждый пиксель изображения испускается луч и находится его точка пересечения с поверхностью сцены. Лучи, выпущенные из глаза, называются \textbf{первичными}~\cite{rt}.

\img{10cm}{trassing.pdf}{Визуализация траектории лучей в алгоритме трассировки лучей}

\pagebreak

Пусть первичный луч пересекает объект 1 в точке H1.

Шаги работы алгоритма трассировки лучей:
\begin{enumerate}
	\item необходимо определить для каждого источника освещения, видна ли из него эта точка;
	\item для каждого источника света до него испускается \textbf{теневой луч} из точки H1~\cite{rt};
	\begin{enumerate}
		\item[2.1.] если теневой луч пересекается с какими-либо объектами, расположенными между точкой и источником света, точка H1 находится в тени и освещать её не надо;
		\item[2.2.] иначе интенсивность считается по некоторой \textbf{модели} (например, Фонг или Гуро);
	\end{enumerate}
	\item освещение со всех видимых (из точки H1) источников света складывается;
	\item если материал объекта 1 имеет отражающие свойства, из точки H1 испускается отраженный луч и для него вся процедура трассировки рекурсивно повторяется.
\end{enumerate}

\textbf{Модели освещения} (отражения) используются для имитации световых эффектов в компьютерной графике, когда свет аппроксимируется на основе физики света.

Существует много моделей освещения, и их можно классифицировать по критериям локальности, использования физических характеристик модели и гладкости модели~\cite{light}.
\begin{enumerate}
	\item По критерию локальности выделяют~\cite{light}:
	\begin{itemize}
		\item[---] локальные модели: учитывается только локальная геометрия объектов. Каждый объект рассматривается независимо от других, без учета их взаимодействия. Такие модели также называются объектно-ориентированными;
	
	    \item[---] глобальные модели: учитываются эффекты взаимодействия между объектами, такие как отражение света между поверхностями. Это приводит к более реалистичным результатам, но требует больших вычислительных ресурсов.
	\end{itemize}

	\item По критерию использования физических характеристик модели выделяют~\cite{light}:
	\begin{itemize}
		\item[---] физические модели: аппроксимируют свойства реальных объектов, учитывая особенности поверхностной структуры и поведение материалов. Например, моделирование кожи или песчинок песка;
		\item[---] эмпирические модели: параметры моделей могут не иметь физической интерпретации, но подбор этих параметров позволяет получать реалистичные изображения.
	\end{itemize}
	\item По критерию гладкости модели выделяют~\cite{light}:
	\begin{itemize}
		\item[---] гладкие модели: поверхность представляется как гладкая. Например, моделирование пластика;
		\item[---] негладкие модели: поверхность рассматривается как набор гладких микрозеркал. Например, моделирование металлических поверхностей.
	\end{itemize}
\end{enumerate}

В более сложных моделях освещения приходится также учитывать преломляющие свойства материала, то есть прозрачность поверхностей, что приводит к появлению преломлённых лучей.

\subsection{Алгоритм Робертса}

Суть алгоритма Робертса заключается в следующем: объекты проецируются на плоскость экрана, где каждое ребро последовательно сравнивается со всеми гранями. 

Варианты взаимного расположения ребра и грани~\cite{rodjers}:
\begin{itemize}
	\item[---] проекции ребра и грани не пересекаются, грань не заслоняет ребро;
	\item[---] проекции ребра и грани пересекаются, но ребро лежит ближе грани, грань не заслоняет ребро;
	\item[---] проекции ребра и грани пересекаются, и ребро лежит дальше грани, грань заслоняет всё ребро или часть ребра;
	\item[---] ребро пересекает грань. 
\end{itemize}

Определение видимости ребра~\cite{rodjers}:
\begin{enumerate}
	\item Если ребро не перекрыто гранью, оно проверяется с последующей гранью.
	\item Если ребро полностью перекрыто, оно считается невидимым и проверка с остальными гранями не выполняется.
	\item Если грань перекрывает часть ребра, ребро разделяется на видимые и невидимые части, и только видимые части продолжаются проверяться с другими гранями.
\end{enumerate}

Производительность можно повысить, если:
\begin{itemize} 
	\item[---] запоминать невидимые интервалы ребра в отдельном массиве, границы интервалов можно отсортировать в порядке возрастания, и затем, перебрав границы в этом порядке, выделить видимые части ребра;
	\item[---] использовать когерентность в пространстве (использовать простые геометрические тела, описанные вокруг объектов --- оболочки).
\end{itemize}

\subsection{Алгоритм Варнока}

Суть работы алгоритма Варнока заключается в анализе областей на экране на наличие в них видимых элементов.

Ниже представлены основные шаги алгоритма~\cite{varnok}.
\begin{enumerate} 
	\item Если в текущем окне, получившемся в результате разбиения предыдущего окна, отсутствует объект или его содержимое просто для визуализации, то в зависимости от отсутствия/присутствия части объекта происходит закрашивание цветом фона/объекта.
	\item Разбиение продолжается до тех пор, пока содержимое фрагментов окна не станет достаточно простым для визуализации или их размеры не достигнут пределов разрешения.
\end{enumerate}

В простейшей оригинальной версии алгоритма окно разбивается на четыре фрагмента (подокна), затем подокно, в котором есть содержимое, разбивается до достижения предела разрешения.

Выделяют следующие типы многоугольников для текущего окна:
\begin{itemize}
	\item[---] внешний --- многоугольник располагается полностью вне окна;
	\item[---] внутренний --- многоугольник полностью располагается внутри окна;
	\item[---] пересекающий --- многоугольник пересекает как минимум одну границу окна;
	\item[---] охватывающий --- окно целиком располагается внутри многоугольника.
\end{itemize}

Рисунок \ref{img:varn} иллюстрирует данные типы многоугольников.

\img{5cm}{varn}{Типы многоугольников: а --- внешний, б --- внутренний, в --- пересекающий, г --- охватывающий}

Правила обработки для каждого окна~\cite{varnok}:
\begin{enumerate}
	\item если в сцене присутствуют только внешние для текущего окна многоугольники, то это окно считается пустым --- оно не разбивается и изображается с фоновой интенсивность или цветом;
	\item если в сцене один внутренний многоугольник, то площадь вне многоугольника изображается с фоновой интенсивностью или цветом, а площадь внутри многоугольника, заполняется соответствующим ему цветом или интенсивностью;
	\item если в сцене располагается пересекающий многоугольник, то площадь вне многоугольника изображается с фоновой интенсивностью или цветом, а площадь внутри многоугольника, которая располагается внутри окна, заполняется соответствующим ему цветом или интенсивностью;
	\item если в сцене присутствует один охватывающий многоугольник, то окно изображается с интенсивностью или цветом соответствующими охватывающему многоугольнику;
	\item если в сцене присутствует хотя бы один охватывающий многоугольник, расположенный ближе других к точке наблюдения, то окно заполняется интенсивностью или цветом, соответствующими охватывающему многоугольнику.
\end{enumerate}

Последний пункт позволяет решать задачу удаления невидимых поверхностей.

\subsection{Алгоритм Вейлера-Азертона}

Алгоритм Вейлера-Азертона по сути является модификацией алгоритма Варнока. Вейлер и Азертон предложили перейти от прямоугольных разбиений к разбиениям вдоль границ многоугольников. Для этого был применён алгоритм отсечения многоугольников~\cite{rodjers}.

Алгоритм Вейлера-Азертона содержит несколько шагов.
\begin{enumerate}
	\item Предварительно проводится сортировка по глубине.
	\item Осуществляется отсечение по границе ближайшего к точке наблюдения многоугольника, называемое сортировкой многоугольников на плоскости.
	\item Многоугольники, экранируемые более близкими к точке наблюдения многоугольниками, удаляются.
	\item Если необходимо, то проводится рекурсивное разбиение и новая сортировка.
\end{enumerate} 

\subsection*{Вывод}

В таблице \ref{tbl:t13} представлено сравнение алгоритмов удаления невидимых рёбер и поверхностей.

\tableimg{10.5cm}{t13}{Cравнение алгоритмов удаления невидимых рёбер и поверхностей}

Для выполнения курсовой работы был выбран алгоритм, использующий Z-буфер, так как он подходит для решения поставленных задач и обладает линейной оценкой трудоёмкости, также позволяет решать задачу построения теней.

\section{Алгоритм построения теней}

Выделяют три класса алгоритмов построения теней~\cite{shadow}.
\begin{enumerate}
	\item Вычисление затенения в процессе преобразования в растровый вид.
	
	К \textbf{первому классу} относятся алгоритмы, основанные на принципе
	отбрасывания лучей, и алгоритмы, которые включают метод трассирования
	лучей как составную часть.
	\item Разделение поверхностей объекта на теневые и нетеневые площади, предшествующее преобразованию в растровый вид.
	
	\textbf{Второй класс} алгоритмов использует известные алгоритмы определения
	видимых поверхностей. При этом используются двухпроходные реализации
	алгоритмов построчного сканирования или Z-буфера.
	\item Включение значения теней в данные, описывающие объект.
	
	Алгоритмы, относящиеся к \textbf{третьему классу}, заносят в базу данных
	информацию о <<затененных>> полигональных областях.
\end{enumerate}

Так как в разделе анализа алгоритмов удаления невидимых рёбер и поверхностей был выбран алгоритм Z-буфера, то будет рассмотрен только алгоритм построения теней с использованием карт теней, который сочетается с алгоритмом Z-буфера~\cite{shadow, shadow2}.

\subsection{Алгоритм построения карты теней}

Для построения теней с использованием алгоритма Z-буфера требуется два прохода: один относительно источника света и другой относительно наблюдателя. Для этого используется отдельный «теневой» буфер глубины~\cite{shadow}.
\begin{enumerate}
	\item Во время первого прохода определяются точки, видимые со стороны источника света.
	\item Во втором проходе сцена отображается с позиции наблюдателя с учетом того, что точки, которые были невидимы со стороны источника света, находятся в тени.
\end{enumerate} 

\section{Анализ алгоритмов закрашивания}

Среди методов закрашивания выделяют простую закраску, закраску методом Гуро и закраску методом Фонга~\cite{rodjers}.

Задача закраски состоит в определении интенсивности цвета объекта или части объекта $I$ в зависимости от параметров объектов сцены (раздел \ref{sec:formalize}):
\begin{itemize}
	\item[---] оптических свойств объекта ($k_d$, $k_a$, $k_s$);
	\item[---] вектора наблюдения $V$;
	\item[---] направления $D$ и мощности $P$ источника света.
\end{itemize}

\subsection{Простая закраска}

Для изображаемой грани объекта вычисляется один уровень интенсивности освещения, который и используется для закраски всего объекта~\cite{rodjers}. Этот уровень интенсивности освещения вычисляется по \textbf{закону косинусов Ламберта}: интенсивность \textbf{диффузно отраженного} света пропорциональна косинусу угла между направлением света и нормалью к поверхности $n$~\cite{rodjers, light}: 
\begin{equation}
I = P k_d (D, n).
\end{equation}

Необходимо также учитывать отражённый от других объектов свет --- \textbf{рассеянный} свет --- и \textbf{зеркальную} составляющую света. В простых моделях можно использовать \textbf{эмпирическую модель Фонга}~\cite{rodjers, light}:

\begin{equation}
	I =  P k_a + P (k_d (D, n) + k_s (D_n, V)^m ) / (d + K)
\end{equation}

где $D_n$ --- вектор отражённого относительно нормали $n$ луча, $m$ --- степень, аппроксимирующая пространственное распределение зеркально отраженного света, $K$ --- произвольная постоянная, $d$ --- расстояние от объекта до источника света.

Для того чтобы применить данную модель освещения, необходимо вычислить нормаль и вектор отражения в каждой точке поверхности. Такой подход будет создавать изображение, состоящее из отдельно видимых полигонов~\cite{rodjers, light}.

Этот эффект продемонстрирован на рисунке \ref{img:ex1}.

\img{6cm}{ex1}{Эффект отсутствия сглаживания}
 \pagebreak

\subsection{Закраска методом Гуро}

Метод закраски Гуро использует аппроксимацию нормалей к поверхности в вершинах многоугольников и билинейную интерполяцию интенсивности освещения каждого пикселя сканирующей строки~\cite{light}. 

Интенсивность в точке $P$ на рисунке \ref{img:mguro} --- $I_3$ --- вычисляется следующим образом:

 \img{10cm}{mguro}{Интерполяция интенсивности}

 
Необходимо ввести следующие векторы для интенсивностей в точках:
\begin{equation}
	\label{eqn:v1} 
	I^1 = 
	\begin{bmatrix}
		I_b \\
		I_c
	\end{bmatrix},
	I^2 = \begin{bmatrix}
		I_b \\
		I_c
	\end{bmatrix},
	I^3 = \begin{bmatrix}
		I^1\\
		I^2
	\end{bmatrix}
\end{equation}

Также необходимы следующие векторы для расчёта коэффициентов при интенсивностях:
\begin{equation}
	\label{eqn:v2}
	y^1 = \begin{bmatrix}
		\frac{y_3-y_a}{y_b-y_a}\\
		\frac{y_b-y_3}{y_b-y_a}
	\end{bmatrix},
	y^2 = \begin{bmatrix}
		\frac{y_3-y_c}{y_b-y_c}\\
		\frac{y_b-y_3}{y_b-y_c}
	\end{bmatrix}
\end{equation}

Тогда с учётом формул \ref{eqn:v1} и \ref{eqn:v2} можно вычислить интенсивность $Int(3)$:

\begin{equation}
	I_3 = I^1\cdot y^1 \cdot \frac{x_b-x_3}{x_b-x_a} + I^2\cdot y^2 \cdot \frac{x_3-x_a}{x_b-x_a}
\end{equation}

Для цветных объектов интерполируется каждая компонента цвета.

Лучше всего закраска Гуро выглядит в сочетании с простой моделью освещения с диффузным отражением. Блики при зеркальном отражении могут выглядеть нереалистично~\cite{light}.

\subsection{Закраска методом Фонга}

Закраска методом Фонга потребляет гораздо больше вычислительных ресурсов, нежели закраска методом Гуро, однако объекты выглядят более реалистично, в частности качественнее отображаются зеркальные блики~\cite{light}.

При закраске Фонга аппроксимация кривизны поверхности осуществляется сначала в вершинах многоугольников путём аппроксимации нормали к вершине. То есть по нормалям к грани определяются нормали к вершинам (в каждой точке закрашиваемой грани интерполируется вектор нормали). Таким образом интерполируется не значение интенсивности каждого пикселя сканирующей строки, а нормали.

Необходимо ввести векторы ($n_i$ --- нормаль к точке $i$):

\begin{equation}
	a^1 = \begin{bmatrix}
		a\\
		(1-a)
	\end{bmatrix}, a \in \{u, w, t\}
\end{equation}

\begin{equation}
	n^1 = \begin{bmatrix}
		n_2\\
		n_1
	\end{bmatrix},
	n^2 = \begin{bmatrix}
		n_1\\
		n_3
	\end{bmatrix},
	n^3 = \begin{bmatrix}
		n^1\\
		n^2
	\end{bmatrix}
\end{equation}

Используя рисунок \ref{img:mguro}, получим:

\begin{equation}
	n_1 = u^1 \cdot n^1,
	n_2 = u^2 \cdot n^2
\end{equation}

В итоге интенсивность в точке $Int(3)$ вычисляется по формуле:
\begin{equation}
	I_3 = t^1 \cdot n
\end{equation}

где $u = \frac{y_a-y_2}{y_1-y_2}, w = \frac{y_1-y_b}{y_1-y_3}, t = \frac{x_p-x_a}{x_b-x_a}, n = \begin{bmatrix}
	n_1\\
	n_2
\end{bmatrix}.$

\subsection*{Вывод}

В таблице \ref{tbl:t23} представлено сравнение алгоритмов закраски:

\tableimg{5.3cm}{t23}{Сравнение алгоритмов закраски}

Для курсовой работы был выбран метод закраски Гуро в сочетании с моделью освещения Фонга, так как он даёт возможность построения кривых гладких поверхностей.

\subsection*{Вывод}

В данном разделе была формализована поставленная задача, была проведена формализация объектов сцены, был дан обзор способов задания трёхмерных объектов, алгоритмов удаления невидимых рёбер и повехностей, алгоритмов построения теней, алгоритмов закраски. 

Был выбран поверхностный способ задания объектов, алгоритм Z-буфера для удаления невидимых рёбер и поверхностей с использованием карт теней и метод закраски Гуро с моделью освещения Фонга.





	