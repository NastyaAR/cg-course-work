\chapter{Аналитический раздел}
\fontsize{16}{19}\selectfont

В данном разделе рассматриваются теоретические основы алгоритмов компьютерной графики для создания трёхмерных изображений.

\section{Формализация объектов синтезируемой сцены}

Исходя из ожидаемых результатов работы программы, кадр видео должен содержать следующие объекты:
\begin{itemize}
	\item[---] шарик, представляющий собой сферу;
	\item[---] качели, имеющие форму параллелепипеда со скруглёнными углами (каждая качель имеет крепление).
\end{itemize}

Можно выделить основные свойства шарика и качелей:
\begin{itemize}
	\item[---] цвет поверхности;
	\item[---] выпуклость;
	\item[---] оптические свойства материала;
	\item[---] скорость движения.
\end{itemize}

\section{Анализ способов задания трёхмерных объектов}
Существуют несколько способов моделирования трёхмерных объектов:
\begin{itemize}
	\item[---] аппроксимация поверхностей объекта большим количеством многоугольников (например, треугольников) --- данный тип называется \textbf{поверхностным};
	\item[---] задание объекта набором точек и рёбер, их соединяющих --- это \textbf{каркасный} тип модели;
	\item[---] формирование тела  из отдельных простых геометрических объёмных элементов с помощью операций объединения, пересечения, вычитания и различных преобразований --- модель \textbf{сплошных тел}.
\end{itemize}

Сравнение способов задания трёхмерных объектов приведено ниже в таблице \ref{tbl:table3}:

\tableimg{7cm}{table3}{Сравнение способов задания моделей}

\subsection*{Вывод}

Для выполнения курсовой работы был выбран поверхностный способ задания объектов, так как он позволяет отрисовывать произвольные объекты.

\section{Анализ алгоритмов удаления невидимых ребер и поверхностей}
Чтобы корректно отобразить один или несколько объектов на сцене, необходимо удалять невидимые рёбра и поверхности.

Для этого нужно:
\begin{enumerate}
	\item удалить все не лицевые поверхности/рёбра;
	\item удалить все видимые поверхности/рёбра, экранируемые другими телами.
\end{enumerate}

Для решения данной задачи существуют несколько алгоритмов, которые можно разделить на три класса в зависимости от пространства работы: пространство объекта, пространство изображения и пространство объекта и изображения в сочетании.

\begin{enumerate}
	\item Алгоритмы, работающие в пространстве \textbf{объекта}: 
		\begin{itemize}
			\item[---] алгоритм Робертса;
			\item[---] алгоритм Вейлера-Азертона.
		\end{itemize}
	\item Алгоритмы, работающие в пространстве \textbf{изображения}: 
		\begin{itemize}
			\item[---] алгоритм плавающего горизонта;
			\item[---] алгоритм с Z-буфером;
			\item[---] алгоритм трассировки лучей;
			\item[---] алгоритм Варнока.
		\end{itemize}
	\item Алгоритмы, формирующие \textbf{список приоритетов}: алгоритм Ньюэла-Ньюэла-Санча.

Далее будут рассмотрены теоретические основы алгоритмов первых двух классов.

\subsection{Алгоритм плавающего горизонта}

Алгоритм плавающего горизонта чаще всего используется для удаления невидимых линий трехмерного представления функций, описывающих поверхность в виде: $F(x, y, z) = 0$.

Трёхмерная задача сводится к двумерной путем пересечения исходной поверхности последовательностью параллельных секущих плоскостей, имеющих постоянные значения координат х, у или z (можно и последовательно применять разные постоянные значения координат для получения более реалистичного изображения). 

Шаги работы алгоритма (при $z=const$, то есть если фиксируется z):
\begin{enumerate}
	\item плоскости $z=const$ упорядочиваются по возрастанию расстояния от них до точки наблюдения;
	\item для каждой плоскости, начиная с ближайшей к наблюдателю, строится кривая, лежащая на ней и принадлежащая объекту, то есть для каждого значения $x$ вычисляется соответствующее значение $y$;
	\item происходит удаление невидимых линий: если на текущей плоскости при некотором заданном значении $x$ соответствующее значение $y$ больше значения $y$ для всех предыдущих кривых при этом значении x, то текущая кривая видима в этой точке, в противном случае она невидима.
\end{enumerate}

Алгоритм определяет обработку объекта чётко математически, что является несомненным достоинством, однако возникают несколько проблем, в числе которых: 
\begin{itemize}
	\item[---] необходимость интерполяции значений $y$, если не всегда возможно вычислить значение функции;
	\item[---] необходимость подбирать функцию, описывающую объект;
	\item[---] ограниченный набор возможных для отрисовки объектов.
\end{itemize}

Типичный результат, получаемый в результате работы алгоритма представлен ниже:

\img{5cm}{fh}{Результат работы алгоритма плавающего горизонта}

\subsection{Алгоритм, использующий Z-буфер}

Алгоритм, использующий Z-буфер, в специальном буфере для каждого пикселя изображения хранит координату Z и значения RGB-составляющих цвета пикселя. При занесении пикселя в буфер кадра значение его глубины сравнивается со значением глубины пикселя, находящегося на текущий момент в буфере кадра. Если значение координаты $z$ текущего пикселя больше, то есть он ближе к наблюдателю, его атрибуты заносятся в буфер кадра.

Формальное описание алгоритма, использующего Z-буфер:
\begin{enumerate}
	\item буфер кадра заполняется фоновым значением интенсивности или цвета;
	\item Z-буфер заполняется минимальным значением глубины;
	\item каждый отрисовываемый многоугольник преобразуется в растровую форму в произвольном порядке;
	\item для каждого $Pixel(x, y)$ в многоугольнике:
	\begin{enumerate}
		\item[4.1.] вычисляется его глубина $z(x, y)$;
		\item[4.2.] если $z(x, y) > Z_{buf}(x, y)$, то атрибут этого многоугольника (интенсивность, цвет и т. п.) записывается в буфер кадра и $Z_{buf}(x, y)$ заменяется на $z(x, y)$;
	\end{enumerate}
\end{enumerate}  

Если известно уравнение плоскости, содержащей многоугольник, то вычисление глубины пикселя на сканирующей строке в пределах многоугольника можно делать пошагово по формуле 

\begin{equation}
z_n=z - \frac{a}{c}
\end{equation}

где $z_n$ --- глубина пикселя $Pixel_n$ на текущей сканирующей строке, $z$ --- глубина первого слева пикселя на текущей сканирующей строке, $a, c$ --- коэффициенты уравнения плоскости, содержащей обрабатываемый многоугольник.

Алгоритм имеет небольшое количество чётко определённых простых шагов, что делает его достаточно несложным для реализации, визуализация пересечений сложных поверхностей становится тривиальной задачей, но имеются и недостатки, в числе которых, например, большой объём потребляемой памяти для двух буферов.

\subsection*{Построение теней}
Алгоритм, использующий Z-буфер, также позволяет строить падающие тени объектов при помощи так называемых карт теней (shadow mapping).

Для построения теней с использованием алгоритма Z-буфера требуется два прохода: один относительно источника света и другой относительно наблюдателя. Для этого используется отдельный «теневой» буфер глубины. Во время первого прохода определяются точки, видимые со стороны источника света. Во втором проходе сцена отображается с позиции наблюдателя с учетом того, что точки, которые были невидимы со стороны источника света, находятся в тени.

\subsection{Алгоритм трассировки лучей}

Главная идея, составляющая основу алгоритма трассировки лучей, заключается в том, что наблюдатель видит объекты посредством испускаемого неким источником луча света, который падает на объект и затем доходит до наблюдателя, отражаясь, преломляясь или каким-нибудь иным способом.

Если бы лучи отслеживались, начиная от объекта, то алгоритм был бы весьма неэффективен, так как лишь немногие лучи в итоге доходят до наблюдателя. Поэтому было предложено отслеживать лучи в обратном направлении, то есть от наблюдателя к объекту.

Итак, из виртуального глаза через каждый пиксель (pixel) изображения испускается луч и находится его точка пересечения с поверхностью сцены. Лучи, выпущенные из глаза, называются \textbf{первичными} (eye ray).

\img{10cm}{trassing.pdf}{Визуализация траектории лучей в алгоритме трассировки лучей}

\pagebreak

Пусть первичный луч пересекает объект 1 (object 1) в точке H1.

Шаги работы алгоритма трассировки лучей:
\begin{enumerate}
	\item необходимо определить для каждого источника освещения (light, в данном случае пусть они будут точечными), видна ли из него эта точка;
	\item для каждого источника света до него испускается \textbf{теневой луч} (shadow ray) из точки H1;
	\begin{enumerate}
		\item[2.1.] если теневой луч пересекается с какими-либо объектами, расположенными между точкой и источником света, точка H1 находится в тени и освещать её не надо;
		\item[2.2.] иначе интенсивность считается по некоторой \textbf{модели} (Фонг, Гуро и т.д.);
	\end{enumerate}
	\item освещение со всех видимых (из точки H1) источников света складывается;
	\item если материал объекта 1 имеет отражающие свойства, из точки H1 испускается отраженный луч и для него вся процедура трассировки рекурсивно повторяется.
\end{enumerate}

\textbf{Модели освещения} (отражения) используются для имитации световых эффектов в компьютерной графике, когда свет аппроксимируется на основе физики света.

Существует много моделей освещения, и их можно классифицировать по различным критериям.
\begin{enumerate}
	\item Локальные модели: учитывается только локальная геометрия объектов. Каждый объект рассматривается независимо от других, без учета их взаимодействия. Такие модели также называются объектно-ориентированными.

    \item Глобальные модели: учитываются эффекты взаимодействия между объектами, такие как отражение света между поверхностями. Это приводит к более реалистичным результатам, но требует больших вычислительных ресурсов.

	\item Физические модели: аппроксимируют свойства реальных объектов, учитывая особенности поверхностной структуры и поведение материалов. Например, моделирование кожи или песчинок песка. 

	\item Эмпирические модели: параметры моделей могут не иметь физической интерпретации, но подбор этих параметров позволяет получать реалистичные изображения.

	\item Гладкие модели: поверхность представляется как гладкая. Например, моделирование пластика.

	\item Негладкие модели: поверхность рассматривается как набор гладких микрозеркал. Например, моделирование металлических поверхностей.

\end{enumerate}

В более сложных моделях освещения приходится также учитывать преломляющие свойства материала, то есть прозрачность поверхностей, что приводит к появлению преломлённых лучей.

Для увеличения быстродействия алгоритма можно модифицировать алгоритм трассировки лучей, испуская лучи не через каждый пиксель, а через точки, аппроксимирующие полигоны объектов сцены.

Алгоритм приобретает следующий вид:
\begin{enumerate}
	\item цикл по всем полигонам сцены;
	\item генерация луча, проходящего через точку, аппроксимирующую данный полигон;
	\item нахождение точки пересечения луча со всеми объектами сцены, исключая пересечение с рассматриваемым полигоном.: если такого пересечения нет, точка видима, иначе выполнить следующий шаг цикла;
	\item вычисление в случае видимости точки её интенсивности согласно заданной модели освещения;
	\item высвечивание полигона с найденной интенсивностью в соответствии с заданным ему цветом при наложении текстур;
	\item конец цикла.
\end{enumerate}

\subsection{Алгоритм Робертса}

Суть алгоритма Робертса заключается в следующем: объекты проецируются на плоскость экрана, и анализ видимости рёбер или граней происходит уже на плоскости. Каждое ребро последовательно сравнивается со всеми гранями (чаще всего это выпуклые многоугольники). 

Варианты взаимного расположения ребра и грани:
\begin{itemize}
	\item[---] проекции ребра и грани не пересекаются, грань не заслоняет ребро;
	\item[---] проекции ребра и грани пересекаются, но ребро лежит ближе грани, грань не заслоняет ребро;
	\item[---] проекции ребра и грани пересекаются, и ребро лежит дальше грани, грань заслоняет всё ребро или часть ребра;
	\item[---] ребро пересекает грань. 
\end{itemize}

Определение видимости ребра:
\begin{enumerate}
	\item Если ребро не перекрыто гранью, оно проверяется с последующей гранью.
	\item Если ребро полностью перекрыто, оно считается невидимым и проверка с остальными гранями не выполняется.
	\item Если грань перекрывает часть ребра, ребро разделяется на видимые и невидимые части, и только видимые части продолжаются проверяться с другими гранями.
\end{enumerate}

Производительность можно повысить, если:
\begin{itemize} 
	\item[---] не делить ребро после каждого сравнения, а запоминать невидимые интервалы ребра в отдельном массиве, границы интервалов можно отсортировать в порядке возрастания, и затем, перебрав границы в этом порядке, выделить видимые части ребра;
	\item[---] использовать когерентность в пространстве (использовать простые геометрические тела, описанные вокруг объектов --- оболочки).
\end{itemize}

\subsection{Алгоритм Варнока}

Суть работы алгоритма Варнока заключается в анализе областей на экране на наличие в них видимых элементов.

Ниже представлены основные шаги алгоритма.
\begin{enumerate} 
	\item Если в текущем окне, получившемся в результате разбиения предыдущего окна, отсутствует объект или его содержимое просто для визуализации, то в зависимости от отсутствия/присутствия части объекта происходит закрашивание цветом фона/объекта.
	\item Разбиение продолжается до тех пор, пока содержимое фрагментов окна не станет достаточно простым для визуализации или их размеры не достигнут пределов разрешения.
\end{enumerate}

В простейшей оригинальной версии алгоритма окно разбивается на четыре фрагмента (подокна), затем подокно, в котором есть содержимое, разбивается до достижения предела разрешения.

Выделяют следующие типы многоугольников для текущего окна:
\begin{itemize}
	\item[---] внешний --- многоугольник располагается полностью вне окна;
	\item[---] внутренний --- многоугольник полностью располагается внутри окна;
	\item[---] пересекающий --- многоугольник пересекает как минимум одну границу окна;
	\item[---] охватывающий --- окно целиком располагается внутри многоугольника.
\end{itemize}

Рисунок \ref{img:varn} иллюстрирует данные типы многоугольников.

\img{5cm}{varn}{Типы многоугольников: а --- внешний, б --- внутренний, в --- пересекающий, г --- охватывающий}

Правила обработки для каждого окна:
\begin{enumerate}
	\item если в сцене присутствуют только внешние для текущего окна многоугольники, то это окно считается пустым --- оно не разбивается и изображается с фоновой интенсивность или цветом;
	\item если в сцене один внутренний многоугольник, то площадь вне многоугольника изображается с фоновой интенсивностью или цветом, а площадь внутри многоугольника, заполняется соответствующим ему цветом или интенсивностью;
	\item если в сцене располагается пересекающий многоугольник, то площадь вне многоугольника изображается с фоновой интенсивностью или цветом, а площадь внутри многоугольника, которая располагается внутри окна, заполняется соответствующим ему цветом или интенсивностью;
	\item если в сцене присутствует один охватывающий многоугольник, то окно изображается с интенсивностью или цветом соответствующими охватывающему многоугольнику;
	\item если в сцене присутствует хотя бы один охватывающий многоугольник, расположенный ближе других к точке наблюдения, то окно заполняется интенсивностью или цветом, соответствующими охватывающему многоугольнику.
\end{enumerate}

Последний пункт позволяет решать задачу удаления невидимых поверхностей.

\subsection{Алгоритм Вейлера-Азертона}

Алгоритм Вейлера-Азертона по сути является модификацией алгоритма Варнока. Вейлер и Азертон предложили перейти от прямоугольных разбиений к разбиениям вдоль границ многоугольников. Для этого был применён алгоритм отсечения многоугольников.

Алгоритм Вейлера-Азертона содержит несколько шагов.
\begin{enumerate}
	\item Предварительно проводится сортировка по глубине.
	\item Осуществляется отсечение по границе ближайшего к точке наблюдения многоугольника, называемое сортировкой многоугольников на плоскости.
	\item Многоугольники, экранируемые более близкими к точке наблюдения многоугольниками, удаляются.
	\item Если необходимо, то проводится рекурсивное разбиение и новая сортировка.
\end{enumerate} 

\subsection*{Вывод}

В таблице \ref{tbl:table0} представлено сравнение алгоритмов удаления невидимых рёбер и поверхностей.

\tableimg{9cm}{table0}{Cравнение алгоритмов удаления невидимых рёбер и поверхностей}
\pagebreak

Для выполнения курсовой работы был выбран алгоритм, использующий Z-буфер, так как его идея проста, он подходит для решения поставленных задач и обладает приемлемой оценкой трудоёмкости.

\section{Анализ алгоритмов закрашивания}

Так как на выходе работы программы необходимо получить цветное реалистичное изображение, нужно подобрать алгоритм, позволяющий закрасить полигоны, из которых состоят объекты, учитывая тени и расположение источника света.

Рассмотрим три метода закрашивания: простую закраску, закраску методом Гуро и закраску методом Фонга.

\subsection{Простая закраска}

Для изображаемой грани объекта вычисляется один уровень интенсивности освещения, который и используется для закраски всего объекта. Этот уровень интенсивности освещения вычисляется по \textbf{закону косинусов Ламберта}: интенсивность \textbf{диффузно отраженного} света пропорциональна косинусу угла между направлением света и нормалью к поверхности: 
\begin{equation}
I_d = I_l k_d \cos \theta,
\end{equation}
где $I_d$ --- интенсивность диффузно отраженного света;
$I_l$ --- интенсивность источника;
$k_d$ --- коэффициент диффузного отражения ($0  \leq k_d  \leq 1$), который зависит от материала объекта и длины волны падающего на него света, но в простых моделях освещения обычно является постоянным;
$\theta$ --- угол между направлением на источник света и нормалью к поверхности.

Необходимо также учитывать отражённый от других объектов свет --- \textbf{рассеянный} свет --- и \textbf{зеркальную} составляющую света. В простых моделях можно использовать \textbf{эмпирическую модель Фонга}:

\begin{equation}
	I =  I_a k_a + I_l (k_d \cos \theta + k_s \cos ^n\alpha ) / (d + K)
\end{equation}

где $k_a$ --- коэффициент диффузного отражения рассеянного света ($0  \leq k_a  \leq 1$) и $I_a$ --- интенсивность рассеянного света, $I_l$ --- интенсивность источника, $k_d$ --- коэффициент диффузного отражения ($0  \leq k_d  \leq 1$), $\theta$ --- угол между направлением на источник света и нормалью к поверхности, $n$ --- степень, аппроксимирующая пространственное распределение зеркально отраженного света, $k_s$ --- коэффициент зеркально отраженного света, $\alpha$ --- угол между отражённым лучом и вектором наблюдения, $K$ --- произвольная постоянная, $d$ --- расстояние от объекта до источника света.

Для того чтобы применить данную модель освещения, необходимо вычислить нормаль и вектор отражения в каждой точке поверхности. Такой подход будет создавать нереалистичное изображение, состоящее из отдельно видимых полигонов.

Похожий эффект продемонстрирован на рисунке \ref{img:ex1}.

\img{6cm}{ex1}{Эффект отсутствия сглаживания}
 \pagebreak

\subsection{Закраска методом Гуро}

Метод закраски Гуро использует аппроксимацию нормалей к поверхности в вершинах многоугольников и билинейную интерполяцию интенсивности освещения каждого пикселя сканирующей строки. 

Интенсивность в точке $P$ на рисунке \ref{img:mguro} --- $I_3$ --- вычисляется следующим образом:

 \img{10cm}{mguro}{Интерполяция интенсивности}

 
Необходимо ввести следующие векторы для интенсивностей в точках:
\begin{equation}
	\label{eqn:v1} 
	I^1 = 
	\begin{bmatrix}
		I_b \\
		I_c
	\end{bmatrix},
	I^2 = \begin{bmatrix}
		I_b \\
		I_c
	\end{bmatrix},
	I^3 = \begin{bmatrix}
		I^1\\
		I^2
	\end{bmatrix}
\end{equation}

Также необходимы следующие векторы для расчёта коэффициентов при интенсивностях:
\begin{equation}
	\label{eqn:v2}
	y^1 = \begin{bmatrix}
		\frac{y_3-y_a}{y_b-y_a}\\
		\frac{y_b-y_3}{y_b-y_a}
	\end{bmatrix},
	y^2 = \begin{bmatrix}
		\frac{y_3-y_c}{y_b-y_c}\\
		\frac{y_b-y_3}{y_b-y_c}
	\end{bmatrix}
\end{equation}

Тогда с учётом формул \ref{eqn:v1} и \ref{eqn:v2} можно вычислить интенсивность $Int(3)$:

\begin{equation}
	I_3 = I^1\cdot y^1 \cdot \frac{x_b-x_3}{x_b-x_a} + I^2\cdot y^2 \cdot \frac{x_3-x_a}{x_b-x_a}
\end{equation}

Для цветных объектов интерполируется каждая компонента цвета.

Лучше всего закраска Гуро выглядит в сочетании с простой моделью освещения с диффузным отражением. Блики при зеркальном отражении могут выглядеть нереалистично.

\subsection{Закраска методом Фонга}

Закраска методом Фонга потребляет гораздо больше вычислительных ресурсов, нежели закраска методом Гуро, однако объекты выглядят более реалистично, в частности качественнее отображаются зеркальные блики.

При закраске Фонга аппроксимация кривизны поверхности осуществляется сначала в вершинах многоугольников путём аппроксимации нормали к вершине. То есть по нормалям к грани определяются нормали к вершинам (в каждой точке закрашиваемой грани интерполируется вектор нормали). Таким образом интерполируется не значение интенсивности каждого пикселя сканирующей строки, а нормали.

Необходимо ввести векторы ($n_i$ --- нормаль к точке $i$):

\begin{equation}
	a^1 = \begin{bmatrix}
		a\\
		(1-a)
	\end{bmatrix}, a \in \{u, w, t\}
\end{equation}

\begin{equation}
	n^1 = \begin{bmatrix}
		n_2\\
		n_1
	\end{bmatrix},
	n^2 = \begin{bmatrix}
		n_1\\
		n_3
	\end{bmatrix},
	n^3 = \begin{bmatrix}
		n^1\\
		n^2
	\end{bmatrix}
\end{equation}

Используя рисунок \ref{img:mguro}, получим:

\begin{equation}
	n_1 = u^1 \cdot n^1,
	n_2 = u^2 \cdot n^2
\end{equation}

В итоге интенсивность в точке $Int(3)$ вычисляется по формуле:
\begin{equation}
	I_3 = t^1 \cdot n
\end{equation}

где $u = \frac{y_a-y_2}{y_1-y_2}, w = \frac{y_1-y_b}{y_1-y_3}, t = \frac{x_p-x_a}{x_b-x_a}, n = \begin{bmatrix}
	n_1\\
	n_2
\end{bmatrix}.$

\subsection*{Вывод}

В таблице \ref{tbl:table2} представлено сравнение алгоритмов закраски:

\tableimg{11.5cm}{table2}{Сравнение алгоритмов закраски}
\pagebreak

Для курсовой работы был выбран метод закраски Гуро в сочетании с моделью освещения Фонга, так как он даёт высокую степень реалистичности изображения и имеет удовлетворительную скорость работы.

\subsection{Функциональная модель программы}

Функциональная модель программы в нотации IDEF0 представлена на рисунке \ref{img:idef0}:

\img{10cm}{idef0}{Функциональная модель программы}
\pagebreak

\subsection*{Вывод}

В данном разделе было произведено исследование предметной области, проведена формализация объектов сцены, обзор способов задания трёхмерных объектов, алгоритмов удаления невидимых рёбер, алгоритмов закраски.

Был выбран поверхностный способ задания объектов, алгоритм Z-буфера для удаления невидимых рёбер и поверхностей с использованием карт теней и метод закраски Гуро с моделью освещения Фонга.





	